// See https://github.com/manyeyes for more information
// Copyright (c) 2025 by manyeyes
using ManySpeech.AudioSep.Model;
using System;
using System.Collections.Generic;

namespace ManySpeech.AudioSep
{
    /// <summary>
    /// Represents an offline audio stream processor that handles audio sample accumulation,
    /// decoded chunk management, and resource disposal.
    /// </summary>
    public class OfflineStream : IDisposable
    {
        #region Private Fields
        private bool _disposed;
        private string _audioId = string.Empty;
        private List<ModelOutputEntity> _modelOutputEntities = new List<ModelOutputEntity>();
        private FrontendConfEntity _frontendConfEntity;
        private WavFrontend _wavFrontend;
        private ModelInputEntity _modelInputEntity;
        private CustomMetadata _customMetadata = new CustomMetadata();
        private List<long> _tokens = new List<long>();
        private List<int> _timestamps = new List<int>();
        private static readonly object _syncLock = new object(); // For thread-safe operations
        private int _offset;
        private int _channels = 1;
        private int _sampleRate = 16000;
        #endregion

        #region Constructor
        /// <summary>
        /// Initializes a new instance of the <see cref="OfflineStream"/> class.
        /// </summary>
        /// <param name="mvnFilePath">Path to the mean-variance normalization file.</param>
        /// <param name="asrProj">Speech separation project instance providing configuration.</param>
        internal OfflineStream(string mvnFilePath, ISepProj asrProj)
        {
            if (asrProj != null)
            {
                _channels = asrProj.Channels;
                _sampleRate = asrProj.SampleRate;
            }

            _modelInputEntity = new ModelInputEntity();
            _frontendConfEntity = new FrontendConfEntity();
            _wavFrontend = new WavFrontend(_frontendConfEntity);
        }
        #endregion

        #region Public Properties
        /// <summary>
        /// Gets or sets the model input entity containing audio data.
        /// </summary>
        public ModelInputEntity ModelInputEntity
        {
            get => _modelInputEntity;
            set => _modelInputEntity = value;
        }

        /// <summary>
        /// Gets or sets the unique identifier for the audio stream.
        /// </summary>
        public string AudioId
        {
            get => _audioId;
            set => _audioId = value ?? string.Empty;
        }

        /// <summary>
        /// Gets or sets the list of model output entities generated by processing.
        /// </summary>
        public List<ModelOutputEntity> ModelOutputEntities
        {
            get => _modelOutputEntities;
            set => _modelOutputEntities = value ?? new List<ModelOutputEntity>();
        }

        /// <summary>
        /// Gets or sets the number of audio channels.
        /// </summary>
        public int Channels
        {
            get => _channels;
            set => _channels = value > 0 ? value : 1;
        }

        /// <summary>
        /// Gets or sets the list of tokens generated during processing.
        /// </summary>
        public List<long> Tokens
        {
            get => _tokens;
            set
            {
                if (value != null)
                {
                    _tokens.Clear();
                    _tokens.AddRange(value);
                }
            }
        }

        /// <summary>
        /// Gets or sets the list of timestamps corresponding to processed tokens.
        /// </summary>
        public List<int> Timestamps
        {
            get => _timestamps;
            set
            {
                if (value != null)
                {
                    _timestamps.Clear();
                    _timestamps.AddRange(value);
                }
            }
        }

        /// <summary>
        /// Gets or sets the current offset position in the audio stream.
        /// </summary>
        public int Offset
        {
            get => _offset;
            set => _offset = value >= 0 ? value : 0;
        }

        /// <summary>
        /// Gets or sets the audio sample rate (Hz).
        /// </summary>
        public int SampleRate
        {
            get => _sampleRate;
            set => _sampleRate = value > 0 ? value : 16000;
        }
        #endregion

        #region Public Methods
        /// <summary>
        /// Adds audio samples to the stream in a thread-safe manner, appending to existing data.
        /// </summary>
        /// <param name="samples">Array of audio samples to add. Must not be null.</param>
        /// <exception cref="ArgumentNullException">Thrown when <paramref name="samples"/> is null.</exception>
        public void AddSamples(float[] samples)
        {
            if (samples == null)
                throw new ArgumentNullException(nameof(samples), "Audio samples cannot be null.");

            lock (_syncLock)
            {
                int currentLength = _modelInputEntity.SpeechLength;
                int newLength = currentLength + samples.Length;
                float[] newSamples = new float[newLength];

                // Copy existing data if available
                if (currentLength > 0 && _modelInputEntity.Speech != null)
                {
                    Array.Copy(_modelInputEntity.Speech, 0, newSamples, 0, currentLength);
                }

                // Copy new samples
                Array.Copy(samples, 0, newSamples, currentLength, samples.Length);

                // Update input entity
                _modelInputEntity.Speech = newSamples;
                _modelInputEntity.SpeechLength = newLength;
            }
        }

        /// <summary>
        /// Retrieves the current chunk of audio data ready for decoding in a thread-safe manner.
        /// </summary>
        /// <returns>Array of audio samples, or null if no data exists.</returns>
        public float[]? GetDecodeChunk()
        {
            lock (_syncLock)
            {
                // Return a copy to prevent external modification of internal data
                if (_modelInputEntity.Speech == null)
                    return null;

                float[] chunkCopy = new float[_modelInputEntity.SpeechLength];
                Array.Copy(_modelInputEntity.Speech, chunkCopy, _modelInputEntity.SpeechLength);
                return chunkCopy;
            }
        }

        /// <summary>
        /// Clears the decoded chunk data in a thread-safe manner.
        /// </summary>
        public void RemoveDecodedChunk()
        {
            lock (_syncLock)
            {
                _modelInputEntity.Speech = null;
                _modelInputEntity.SpeechLength = 0;
            }
        }

        /// <summary>
        /// Removes all accumulated audio samples in a thread-safe manner.
        /// </summary>
        public void RemoveSamples()
        {
            lock (_syncLock)
            {
                _modelInputEntity.Speech = null;
                _modelInputEntity.SpeechLength = 0;
            }
        }
        #endregion

        #region IDisposable Implementation
        /// <summary>
        /// Releases the unmanaged resources used by the <see cref="OfflineStream"/> and optionally releases managed resources.
        /// </summary>
        /// <param name="disposing">true to release both managed and unmanaged resources; false to release only unmanaged resources.</param>
        protected virtual void Dispose(bool disposing)
        {
            if (!_disposed)
            {
                if (disposing)
                {
                    // Dispose managed resources
                    _modelOutputEntities.Clear();
                    _tokens.Clear();
                    _timestamps.Clear();

                    _modelInputEntity.Speech = null;
                    _modelInputEntity.SpeechLength = 0;
                }

                _disposed = true;
            }
        }

        /// <summary>
        /// Releases all resources used by the <see cref="OfflineStream"/>.
        /// </summary>
        public void Dispose()
        {
            Dispose(disposing: true);
            GC.SuppressFinalize(this);
        }

        /// <summary>
        /// Finalizer for <see cref="OfflineStream"/>, ensuring unmanaged resources are released.
        /// </summary>
        ~OfflineStream()
        {
            Dispose(disposing: false);
        }
        #endregion
    }
}