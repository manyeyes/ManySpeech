// See https://github.com/manyeyes for more information
// Copyright (c) 2025 by manyeyes
using ManySpeech.AudioSep.Model;
using System;
using System.Collections.Generic;

namespace ManySpeech.AudioSep
{
    /// <summary>
    /// Represents an offline audio stream processor that handles audio sample accumulation,
    /// decoding chunks management, and resource disposal.
    /// </summary>
    public class OfflineStream : IDisposable
    {
        #region Private Fields
        private bool _disposed;
        private string _audioId = string.Empty;
        private List<ModelOutputEntity> _modelOutputEntities;
        private FrontendConfEntity _frontendConfEntity;
        private WavFrontend _wavFrontend;
        private ModelInputEntity _modelInputEntity;
        private CustomMetadata _customMetadata;
        private List<long> _tokens = new List<long>();
        private List<int> _timestamps = new List<int>();
        private List<float[]> _states = new List<float[]>();
        private static readonly object _syncLock = new object(); // Thread synchronization lock
        private int _offset = 0;
        private int _channels = 1;
        private int _sampleRate = 16000;
        #endregion

        #region Constructor
        /// <summary>
        /// Initializes a new instance of the OfflineStream class.
        /// </summary>
        /// <param name="mvnFilePath">Path to the mean-variance normalization file.</param>
        /// <param name="asrProj">Speech separation project instance providing configuration.</param>
        internal OfflineStream(string mvnFilePath, ISepProj asrProj)
        {
            if (asrProj != null)
            {
                _channels = asrProj.Channels;
                _sampleRate = asrProj.SampleRate;
            }

            _modelInputEntity = new ModelInputEntity();
            _frontendConfEntity = new FrontendConfEntity();
            _wavFrontend = new WavFrontend(_frontendConfEntity);
        }
        #endregion

        #region Public Properties
        /// <summary>
        /// Gets or sets the model input entity containing audio data.
        /// </summary>
        public ModelInputEntity ModelInputEntity
        {
            get => _modelInputEntity;
            set => _modelInputEntity = value;
        }

        /// <summary>
        /// Gets or sets the unique identifier for the audio stream.
        /// </summary>
        public string AudioId
        {
            get => _audioId;
            set => _audioId = value;
        }

        /// <summary>
        /// Gets or sets the list of model output entities generated by processing.
        /// </summary>
        public List<ModelOutputEntity> ModelOutputEntities
        {
            get => _modelOutputEntities;
            set => _modelOutputEntities = value;
        }

        /// <summary>
        /// Gets or sets the number of audio channels.
        /// </summary>
        public int Channels
        {
            get => _channels;
            set => _channels = value;
        }

        /// <summary>
        /// Gets or sets the list of tokens generated during processing.
        /// </summary>
        public List<long> Tokens
        {
            get => _tokens;
            set => _tokens = value;
        }

        /// <summary>
        /// Gets or sets the list of timestamps corresponding to processed tokens.
        /// </summary>
        public List<int> Timestamps
        {
            get => _timestamps;
            set => _timestamps = value;
        }

        /// <summary>
        /// Gets or sets the list of states maintained during processing.
        /// </summary>
        public List<float[]> States
        {
            get => _states;
            set => _states = value;
        }

        /// <summary>
        /// Gets or sets the current offset position in the audio stream.
        /// </summary>
        public int Offset
        {
            get => _offset;
            set => _offset = value;
        }

        /// <summary>
        /// Gets or sets the audio sample rate (Hz).
        /// </summary>
        public int SampleRate
        {
            get => _sampleRate;
            set => _sampleRate = value;
        }
        #endregion

        #region Public Methods
        /// <summary>
        /// Adds audio samples to the stream, appending to existing data in thread-safe manner.
        /// </summary>
        /// <param name="samples">Array of audio samples to add.</param>
        public void AddSamples(float[] samples)
        {
            lock (_syncLock)
            {
                int currentLength = _modelInputEntity.SpeechLength;
                float[] newSamples = new float[currentLength + samples.Length];

                // Copy existing data if available
                if (currentLength > 0)
                {
                    Array.Copy(_modelInputEntity.Speech, 0, newSamples, 0, currentLength);
                }

                // Copy new samples
                Array.Copy(samples, 0, newSamples, currentLength, samples.Length);

                // Update input entity
                _modelInputEntity.Speech = newSamples;
                _modelInputEntity.SpeechLength = newSamples.Length;
            }
        }

        /// <summary>
        /// Retrieves the current chunk of audio data ready for decoding in thread-safe manner.
        /// </summary>
        /// <returns>Array of audio samples, or null if no data exists.</returns>
        public float[]? GetDecodeChunk()
        {
            lock (_syncLock)
            {
                return _modelInputEntity.Speech;
            }
        }

        /// <summary>
        /// Clears the decoded chunk data in thread-safe manner.
        /// </summary>
        public void RemoveDecodedChunk()
        {
            lock (_syncLock)
            {
                _modelInputEntity.Speech = null;
                _modelInputEntity.SpeechLength = 0;
            }
        }

        /// <summary>
        /// Removes all accumulated audio samples in thread-safe manner.
        /// </summary>
        public void RemoveSamples()
        {
            lock (_syncLock)
            {
                _modelInputEntity.Speech = null;
                _modelInputEntity.SpeechLength = 0;
            }
        }
        #endregion

        #region IDisposable Implementation
        /// <summary>
        /// Releases the unmanaged resources used by the OfflineStream and optionally releases managed resources.
        /// </summary>
        /// <param name="disposing">true to release both managed and unmanaged resources; false to release only unmanaged resources.</param>
        protected virtual void Dispose(bool disposing)
        {
            if (!_disposed)
            {
                if (disposing)
                {
                    // Dispose managed resources
                    _modelOutputEntities?.Clear();
                    _modelOutputEntities = null;
                    _tokens.Clear();
                    _timestamps.Clear();
                    _states.Clear();
                }

                // Mark as disposed
                _disposed = true;
            }
        }

        /// <summary>
        /// Releases all resources used by the OfflineStream.
        /// </summary>
        public void Dispose()
        {
            Dispose(disposing: true);
            GC.SuppressFinalize(this);
        }

        /// <summary>
        /// Finalizer for OfflineStream, ensuring unmanaged resources are released.
        /// </summary>
        ~OfflineStream()
        {
            Dispose(disposing: false);
        }
        #endregion
    }
}